<?php
// $Id$

/**
 * Implementation of hook_init().
 */
function icon_init() {
  init_theme(); // TODO: Get the theme name without calling init_theme().
  global $_icons, $theme;

  // Retrieve icons for current theme from cache (or rebuild it).
  $_icons = icon_get_icons($theme);

  // Add icon stylesheet file, if one has been generated for this theme.
  $stylesheet = variable_get('icon_'. $theme .'_stylesheet', NULL);
  if ($stylesheet) {
    drupal_add_css($stylesheet, 'theme', 'all', FALSE);
  }
}

/**
 * Implementation of hook_theme().
 */
function icon_theme() {
  return array(
    'icon' => array(
      'arguments' => array('name' => NULL, 'size' => NULL),
    ),
    'icon_iconsets_form' => array(
      'template' => 'icon-iconsets-form',
      'arguments' => array('form' => NULL),
    ),
  );
}

/**
 * Implementation of hook_perm().
 */
function icon_perm() {
  return array('administer icons');
}

/**
 * Implementation of hook_menu().
 */
function icon_menu() {
  $items['admin/build/themes/icons'] = array(
    'title' => 'Icons',
    'page callback' => 'icon_iconsets',
    'access arguments' => array('administer icons'),
    'file' => FALSE,
    'type' => MENU_LOCAL_TASK,
  );

  $items['admin/build/themes/icons/settings'] = array(
    'title' => 'Global settings',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -10,
  );

  foreach (list_themes() as $key => $theme) {
    $items['admin/build/themes/icons/'. $key] = array(
      'title' => $theme->info['name'],
      'page arguments' => array($key),
      'access callback' => '_icon_themes_access',
      'access arguments' => array($theme),
      'type' => MENU_LOCAL_TASK,
    );
  }

  return $items;
}

/**
 * Menu item access callback - only admin or enabled themes with icons, or
 * with ancestor themes having icons, can be accessed.
 */
function _icon_themes_access($theme) {
  if (user_access('administer icons') && ($theme->status || $theme->name == variable_get('admin_theme', '0')) && _icon_theme_with_icons($theme->name)) {
    return TRUE;
  }
}

/**
 * Check if the theme has icons or ancestors with icons.
 *
 * @param $theme
 *   Name of the theme.
 * @return
 *   The theme object that has icons. Returns NULL if no icons were found in
 *   the theme itself or any ancestors.
 */
function _icon_theme_with_icons($theme) {
  static $icons_theme = array();

  if (!isset($icons_theme[$theme])) {
    $themes = list_themes();
    do {
      if (is_array($themes[$theme]->info['icons'])) {
        $icons_theme[$theme] = $themes[$theme];
        break;
      }
      $theme = $themes[$theme]->base_theme;
    } while ($theme);
  }

  return $icons_theme[$theme];
}

/**
 * Collect data about icon sets available to a particular theme.
 *
 * @param $theme
 *   The theme to get available icon sets for.
 * @param $reset
 *   (optional) Set to TRUE to reset the cache.
 * @return
 *   An array of icon sets.
 */
function icon_get_iconsets($theme, $reset = FALSE) {
  static $iconsets = array();

  if (!isset($iconsets[$theme]) || $reset) {
    if (!$reset && ($cache = cache_get('iconsets:'. $theme)) && !empty($cache->data)) {
      $iconsets[$theme] = $cache->data;
    }
    else {
      // Look for icon sets.
      $temp = _icon_find_iconsets();

      // Look for enabled modules that provide icons.
      $result = db_query("SELECT filename, name, type, info FROM {system} WHERE type = 'module' AND status = 1 ORDER BY weight DESC");
      while ($component = db_fetch_object($result)) {
        $component->info = unserialize($component->info);
        if ($component->info['icons']) {
          $temp[$component->name] = $component;
        }
      }

      // Then add the theme (or the ancestor theme with icons).
      $icons_theme = _icon_theme_with_icons($theme);
      $temp[$icons_theme->name] = $icons_theme;

      // Build an array of only the information we want from the components.
      $iconsets[$theme] = _icon_build_iconset_array($temp);

      // Append statuses and weights and sort icon sets.
      foreach ($iconsets[$theme] as $type => $sets) {
        _icon_append_iconset_states($iconsets[$theme][$type], $theme);
        uasort($iconsets[$theme][$type], '_icon_sort_iconsets');
      }

      // Cache the icon sets for this theme.
      cache_set('iconsets:'. $theme, $iconsets[$theme]);
    }

  }

  return $iconsets[$theme];
}

/**
 * Find all non-base icon sets.
 *
 * @return
 *   An array of icon set files with their info data.
 */
function _icon_find_iconsets() {
  // Locate icon sets' .info files.
  $iconsets = drupal_system_listing('\.info$', 'icons', 'name', 0);

  // Update the current status of icon sets in the database.
  system_get_files_database($iconsets, 'iconsets');

  // Add .info file's content to each icon set.
  foreach ($iconsets as $key => $iconset) {
    $iconsets[$key]->type = 'iconset';
    $iconsets[$key]->info = drupal_parse_info_file($iconset->filename);
  }

  // Delete or update icon sets that have been removed or changed.
  $result = db_query("SELECT filename, name, info FROM {system} WHERE type = 'iconset'");
  while ($item = db_fetch_object($result)) {
    if (($iconsets[$item->name] === NULL) || !file_exists($item->filename)) {
      db_query("DELETE FROM {system} WHERE name = '%s'", $item->name);
      unset($iconsets[$item->name]);
    }
    elseif ($item->info != $iconsets[$item->name]->info) {
      db_query("UPDATE {system} SET info = '%s' WHERE name = '%s'", serialize($iconsets[$item->name]->info));
    }

    // Flag the icon set as processed, meaning it was found in the database.
    $iconsets[$item->name]->processed = TRUE;
  }

  // Icon sets that were not found in the database should be saved.
  foreach ($iconsets as $key => $iconset) {
    if (!$iconset->processed) {
      db_query("INSERT INTO {system} (name, owner, info, type, filename, status, throttle, bootstrap) VALUES ('%s', '%s', '%s', '%s', '%s', %d, %d, %d)", $iconset->name, '', serialize($iconset->info), 'iconset', $iconset->filename, $iconset->status, 0, 0);
    }
    else {
      unset($iconsets[$key]->processed); // Just cleaning up...
    }
  }

  return $iconsets;
}

/**
 * Build an array of icon sets based on information from their files.
 *
 * @param $components
 *   Components to build an array from.
 * @return
 *   An array of icon sets.
 */
function _icon_build_iconset_array($components) {
  $iconsets = array();

  // Set defaults.
  $defaults = array(
    'name' => '',
    'description' => '',
    'screenshot' => 'screenshot.png',
  );

  // Extract the information we want from the components.
  foreach ($components as $key => $value) {
    if (!$value) {
      continue;
    }

    $value->info = $value->info + $defaults;

    // Installed icon sets are 'iconset', module and theme icons are 'base'.
    $type = $value->type == 'iconset' ? 'iconset' : 'base';

    $iconsets[$type][$key] = array(
      'path' => dirname($value->filename),
      'name' => $value->info['name'],
      'description' => $value->info['description'],
      'screenshot' => $value->info['screenshot'],
      'type' => $value->type,
    );

    // Give screenshot a proper path (has already been done for themes).
    if ($value->type != 'theme') {
      $iconsets[$type][$key]['screenshot'] = $iconsets[$type][$key]['path'] .'/'. $iconsets[$type][$key]['screenshot'];
    }

    // Verify that the screenshot actually exists.
    if (!file_exists($iconsets[$type][$key]['screenshot'])) {
      $iconsets[$type][$key]['screenshot'] = NULL;
    }

    // Give base icons a better description.
    if ($type == 'base') {
      $iconsets[$type][$key]['description'] = t('Icons provided by the %component !type.', array('%component' => $value->info['name'], '!type' => $value->type));
    }
  }

  return $iconsets;
}

/**
 * Append statuses and weights to icon sets for a particular theme.
 *
 * @param $iconsets
 *   An array of icon sets to add statuses and weights to.
 * @param $theme
 *   The theme to check for status and weight against.
 */
function _icon_append_iconset_states(&$iconsets, $theme) {
  // Fetch existing values from the database.
  $result = db_query("SELECT iconset, status, weight FROM {iconsets} WHERE theme = '%s'", $theme);
  while ($item = db_fetch_object($result)) {
    $data[$item->iconset] = $item;
  }

  // Define default weights.
  $default_weights = array('iconset' => 0, 'theme' => 1, 'module' => 2);

  foreach ($iconsets as $key => $value) {
    // If the icon set hasn't been saved for this theme, set its defaults.
    // Module and theme sets are enabled by default and cannot be disabled.
    if (!isset($data[$key])) {
      $data[$key]->status = ($iconsets[$key]['type'] == 'iconset' ? 0 : 1);
      $data[$key]->weight = $default_weights[$iconsets[$key]['type']];
    }

    // Append status and weight to the icon set's array item.
    $iconsets[$key]['status'] = ($iconsets[$key]['type'] == 'iconset' ? $data[$key]->status : 1);
    $iconsets[$key]['weight'] = $data[$key]->weight;
  }
}

/**
 * Save statuses and weights for icon sets.
 *
 * @param $iconsets
 *   An array of icon sets to save.
 * @param $theme
 *   The theme for which to save statuses.
 */
function _icon_save_iconset_states($theme, $iconsets = array()) {
  $result = db_query("SELECT iconset, status, weight FROM {iconsets} WHERE theme = '%s'", $theme);

  while ($item = db_fetch_object($result)) {
    // Delete or update icon sets that have been removed or changed.
    if ($iconsets[$item->iconset] === NULL) {
      db_query("DELETE FROM {iconsets} WHERE iconset = '%s' AND theme = '%s'", $item->iconset, $theme);
    }
    elseif ($iconsets[$item->iconset]['status'] != $item->status || $iconsets[$item->iconset]['weight'] != $item->weight) {
      db_query("UPDATE {iconsets} SET status = %d, weight = %d WHERE iconset = '%s' AND theme = '%s'", $iconsets[$item->iconset]['status'], $iconsets[$item->iconset]['weight'], $item->iconset, $theme);
    }

    // Remove processed icon sets from the array.
    unset($iconsets[$item->iconset]);
  }

  // Any remaining icon sets are new and should be saved.
  foreach ($iconsets as $key => $iconset) {
    db_query("INSERT INTO {iconsets} (iconset, theme, status, weight) VALUES ('%s', '%s', %d, %d)", $key, $theme, $iconset['status'], $iconset['weight']);
  }
}

/**
 * Get icons available to the specified theme.
 *
 * @param $theme
 *   Name of the theme for which to get available icons.
 */
function icon_get_icons($theme, $reset = FALSE) {
  static $icons = array();

  if (!isset($icons[$theme]) || $reset) {
    if (!$reset && ($cache = cache_get('icons:'. $theme)) && !empty($cache->data)) {
      // Fetch icons from cache.
      $icons[$theme] = $cache->data;
    }
    else {
      // Collect available icons, resetting the cache.
      $icons[$theme] = element_children(_icon_get_icons($theme));
    }
  }

  return $icons[$theme];
}

/**
 * Collect icons available to the specified theme.
 *
 * @param $theme
 *   Name of the theme for which to get available icons.
 * @param $iconsets
 *   (optional) Icon sets to get available icons from. If left empty, icon
 *   sets available to the specified theme will be fetched.
 * @return
 *   An array of icons for the specified theme. Original => replacement icon
 *   pairs are provided in #rewrites.
 */
function _icon_get_icons($theme, $iconsets = array()) {
  $base_icons = $icons = array();
  $num_iconset = 0;

  // If no icon sets were provided, fetch all icon sets available to the
  // theme, resetting the cache.
  if (empty($iconsets)) {
    $iconsets = icon_get_iconsets($theme, TRUE);
  }

  foreach ($iconsets as $type => $sets) {

    // Sort icon sets, as they may have been rearranged by the user.
    uasort($iconsets[$type], '_icon_sort_iconsets');

    // Reverse the non-base icon sets.
    if ($type == 'iconset') {
      $iconsets[$type] = array_reverse($iconsets[$type]);
    }

    // Fetch all available icons from the icon sets.
    _icon_append_icons($iconsets[$type]);

    foreach ($iconsets[$type] as $key => $iconset) {
      if ($iconset['icons']) {

        // Merge base icons into a separate array and count other icon sets.
        if ($type == 'base') {
          $base_icons += $iconset['icons'];
        } else {
          $num_iconset++;
        }

        // Build the $icons array, overriding the base icons and storing
        // original => replacement pairs in '#rewrites'.
        foreach ($iconset['icons'] as $icon => $sizes) {
          foreach ($sizes as $size => $file) {
            $original = $base_icons[$icon][$size];
            if (!empty($original)) {
              $icons[$icon][$size] = $iconset['path'] .'/'. $file;
              $icons['#rewrites'][$original] = $iconset['path'] .'/'. $file;
            }
          }
        }

      }
    }

  }

  // Don't return only base icons.
  if ($num_iconset == 0) {
    $icons = array();
  }

  // Cache the icons (without the rewrites).
  cache_set('icons:'. $theme, element_children($icons));

  return $icons;
}

/**
 * Append icons to icon sets.
 *
 * @param $iconsets
 *   Icon sets to append icons to.
 */
function _icon_append_icons(&$iconsets) {
  foreach ($iconsets as $key => $iconset) {
    $icons = array();

    // We don't need icons from disabled non-base sets.
    if ($iconsets[$key]['type'] == 'iconset' && $iconsets[$key]['status'] == 0) {
      continue;
    }

    // Fetch the component's .info data.
    $iconsets[$key]['info'] = drupal_parse_info_file($iconsets[$key]['path'] .'/'. $key .'.info');

    if (is_array($iconsets[$key]['info']['icons'])) {
      foreach ($iconsets[$key]['info']['icons'] as $icon => $value) {

        // If the icon has been declared with specific icon sizes, look for
        // files in the specified paths.
        if (is_array($value)) {
          foreach ($value as $size => $file) {
            if (file_exists($iconsets[$key]['path'] .'/'. $file)) {
              $iconsets[$key]['icons'][$icon][$size] = $file;
            }
          }
        }

        // If the icon has no specific size or path specified, look for files
        // in all specified size folders.
        elseif ($iconsets[$key]['info']['sizes']) {
          foreach ($iconsets[$key]['info']['sizes'] as $size => $folder) {
            if (file_exists($iconsets[$key]['path'] .'/'. $folder .'/'. $value)) {
              $iconsets[$key]['icons'][$icon][$size] = $folder .'/'. $value;
            }
          }
        }

      }
    }

  }
}

/**
 * Array sorting callback; sorts icon sets.
 */
function _icon_sort_iconsets($a, $b) {
  // Sort by weight, then name.
  if ($a['weight'] == $b['weight']) {
    return strcasecmp($a['name'], $b['name']);
  }
  else {
    return $a['weight'] > $b['weight'];
  }
}

/**
 * Rewrite stylesheets to replace icons.
 *
 * @param $theme
 *   The theme for which to rewrite stylesheets.
 * @param $icons
 *   Icons to replace the original ones.
 */
function icon_rewrite_stylesheets($theme, $icons) {
  // First delete any existing rewritten stylesheet.
  if ($old_stylesheet = variable_get('icon_'. $theme .'_stylesheet', NULL)) {
    @unlink($old_stylesheet);
    variable_del('icon_'. $theme .'_stylesheet');
  }

  // Only rewrite stylesheets if there are icons to replace.
  if (empty($icons['#rewrites'])) {
    return;
  }

  // Fetch stylesheets added with drupal_add_css().
  $css = drupal_add_css();

  // Merge all stylesheets (optimized) into a single variable.
  $styles = '';
  foreach ($css as $types) {
    foreach ($types as $type) {
      foreach ($type as $path => $preprocess) {
        // Exclude any previously rewritten stylesheet.
        if ($path != $old_stylesheet) {
          $styles .= drupal_load_stylesheet($path, TRUE);
        }
      }
    }
  }

  // Create a new stylesheet, rewriting icon paths in original styles.
  $rewritten = _icon_rewrite_stylesheet($styles, $icons);

  // Save the new stylesheet in the files directory.
  $filename = _icon_save_stylesheet($rewritten, $theme);

  variable_set('icon_'. $theme .'_stylesheet', $filename);
}

/**
 * Rewrite a single stylesheet, replacing icons.
 *
 * @param $styles
 *   A stylesheet's file contents.
 * @param $icons
 *   Icons to replace the original ones.
 * @return
 *   A rewritten stylesheet.
 */
function _icon_rewrite_stylesheet($styles, $icons) {
  // Split the stylesheet into chunks using the '}' delimeter.
  $chunks = preg_split('/\}/', $styles, -1, PREG_SPLIT_NO_EMPTY);

  // Find icon paths and replace them with icons from the selected icon sets.
  foreach ($chunks as $chunk) {
    foreach ($icons['#rewrites'] as $original => $replace) {
      if (strpos($chunk, $original)) {
        $new_icon = base_path() . $replace;
        $selector = substr($chunk, 0, stripos($chunk, '{'));
        $output .= "$selector{background-image:url($new_icon)!important;}";
      }
    }
  }

  return $output;
}

/**
 * Save the rewritten stylesheet to disk.
 *
 * @param $style
 *   Content of the stylesheet to save.
 * @return
 *   Filename of the saved stylesheet relative to the directory.
 */
function _icon_save_stylesheet($style, $theme) {
  // Prepare the directory.
  $directory = file_directory_path() .'/icon';
  file_check_directory($directory, FILE_CREATE_DIRECTORY);

  // Generate a filename.
  $filename = $directory .'/'. $theme .'-'. substr(md5($style . microtime()), 0, 8) .'.css';

  // Write new stylesheet.
  file_save_data($style, $filename, FILE_EXISTS_REPLACE);

  // Set standard file permissions for webserver-generated files.
  @chmod($file, 0664);

  return $filename;
}

/**
 * Menu callback for admin/build/themes/icons.
 */
function icon_iconsets($theme = NULL) {
  if (!$theme) {
    return 'TODO: Remove this tab, go directly to the tab for the current theme.';
  }

  // Fetch and sort icon sets available to the theme, resetting the cache.
  $iconsets = icon_get_iconsets($theme, TRUE);
  foreach ($iconsets as $type => $sets) {
    uasort($iconsets[$type], '_icon_sort_iconsets');
  }

  return drupal_get_form('icon_iconsets_form', $iconsets, $theme);
}

/**
 * Generate icon sets administration form.
 *
 * @ingroup forms
 * @see icon_iconsets_form_submit()
 * @see template_preprocess_icon_iconsets_form()
 */
function icon_iconsets_form(&$form_state, $iconsets, $theme) {
  // Add CSS.
  drupal_add_css(drupal_get_path('module', 'icon') .'/icon.css', 'module', 'all', FALSE);

  $form = array(
    '#tree' => TRUE,
  );

  $form['theme'] = array(
    '#type' => 'value',
    '#value' => $theme,
  );

  // Add form elements for all available icon sets.
  foreach ($iconsets as $type => $sets) {
    foreach ($sets as $key => $data) {
      $form[$key]['iconset'] = array(
        '#type' => 'value',
        '#value' => $data,
      );

      $form[$key]['type'] = array(
        '#type' => 'value',
        '#value' => $type,
      );

      $form[$key]['status'] = array(
        '#type' => 'checkbox',
        '#default_value' => isset($form_state[$key]['status']) ? $form_state[$key]['status'] : $data['status'],
      );

      if ($type == 'base') {
        $form[$key]['status']['#attributes']['disabled'] = 'disabled';
      }

      $form[$key]['weight'] = array(
        '#type' => 'weight',
        '#delta' => 10,
        '#default_value' => isset($form_state[$key]['weight']) ? $form_state[$key]['weight'] : $data['weight'],
        '#attributes' => array('class' => 'iconset-weight iconset-weight-'. $type),
      );
    }
  }

  $form['buttons']['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Save configuration'),
  );
  $form['buttons']['reset'] = array(
    '#type' => 'submit',
    '#value' => t('Reset to defaults'),
  );

  return $form;
}

/**
 * Process icon_iconsets_form form submissions.
 */
function icon_iconsets_form_submit($form, &$form_state) {
  $theme = $form_state['values']['theme'];

  // Default to empty arrays, so that functions further down will reset if
  // 'Reset to defaults' button was clicked.
  $iconsets = array('base' => array(), 'iconset' => array());
  $icons = array();

  // Save icon sets, rebuild icon cache and rewrite stylesheets if
  // 'Save configuration' button was clicked.
  if ($form_state['values']['op'] == t('Save configuration')) {
    foreach ($form_state['values'] as $key => $value) {
      if (is_array($value['iconset'])) {
        $type = $value['type'];

        // Extract the iconset from the form.
        $iconsets[$type][$key] = $value['iconset'];
        $iconsets[$type][$key]['weight'] = $value['weight'];

        // Make sure base sets are always enabled.
        $iconsets[$type][$key]['status'] = ($type == 'base' ? 1 : $value['status']);
      }
    }

    // Fetch icons available to the theme.
    $icons = _icon_get_icons($theme, $iconsets);
  }

  // Save statuses and weights of icon sets for this theme.
  _icon_save_iconset_states($theme, $iconsets['base'] + $iconsets['iconset']);

  // Rewrite stylesheets, replacing the original icons.
  icon_rewrite_stylesheets($theme, $icons);

  drupal_set_message(t('The configuration options have been saved.'));
}

/**
 * Process variables for icon-iconsets-form.tpl.php.
 *
 * The $variables array contains the following arguments:
 * - $form
 *
 * @see icon-iconsets-form.tpl.php
 * @see theme_icon_iconsets_form()
 */
function template_preprocess_icon_iconsets_form(&$variables) {
  $variables['types'] = array(
    'base' => t('Theme and module icons'),
    'iconset' => t('Icon sets'),
  );

  foreach (element_children($variables['form']) as $i) {
    $iconset = &$variables['form'][$i];

    // Only take form elements that are icon sets.
    if (isset($iconset['iconset'])) {
      $type = $iconset['type']['#value'];
      $data = $iconset['iconset']['#value'];

      // Set special classes needed for table drag and drop.
      $variables['form'][$i]['weight']['#attributes']['class'] = 'iconset-weight iconset-weight-'. $type;

      // Render form elements and make them available as variables.
      $variables['iconsets'][$type][$i]->screenshot = $data['screenshot'] ? theme('image', $data['screenshot'], t('Screenshot for %iconset icon set', array('%iconset' => $data['name'])), '', array('class' => 'screenshot'), FALSE) : t('no screenshot');
      $variables['iconsets'][$type][$i]->name = $data['name'];
      $variables['iconsets'][$type][$i]->description = $data['description'];
      $variables['iconsets'][$type][$i]->status_checkbox = drupal_render($iconset['status']);
      $variables['iconsets'][$type][$i]->weight_select = drupal_render($iconset['weight']);
    }
  }

  // This also passes on important hidden form elements.
  $variables['buttons'] = drupal_render($variables['form']);
}

/**
 * Theme function for displaying an icon.
 *
 * @ingroup themeable
 * @param $name
 *   The name of the icon to display.
 * @param $size
 *   (optional) The desired pixel size of the icon to display. Defaults to '32'.
 * @return
 *   A string containing an image tag of the icon.
 */
function theme_icon($name, $size = '32') {
  global $_icons;
  return theme('image', $_icons[$name][$size]);
}
